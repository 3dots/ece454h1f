ECE454H1F Computer Systems Programming
Lab 4

By: 	Viktor Riabtsev
		997544420
		
Q1.
Well, program size for one. But really, in the case of global lock vs list lock versions for example, we'd get conflicting code. We'de be intializing structures we don't need to, as well as invoking functions that would slow us down.

Q2.
If this is a round about way of pointing out that using transactional memory was, code-wise, a lot simpler, then I agree.

Q3.
No. The whole concept of "list-level" implies you have looked into the structural implementation. Besides, deciding which list is affected, and then calling to modify it, all happen inside the hash implementation.

Q4.
No. You need to initialize the mutex locks, and while in our case the number of mutexes is fixed, the implmentation actually expects a size parameter during setup, which we need to accomodate dynamically. Similiarly, after we are done with the hash structures, we need to clean them up (which noone ever does in the original implementation), and most importantly, accoriding to the api, an initialized mutex must be "destroyed", thus we need to affect the clean up function as well. 

Q5.
If by this one function you mean uniting all the operations that need to be atomic, and then locking a particular list when it is decided on, and then doing the necessary operations: finding the requested sample and incrementing it, or inserting a new one if not found and intializing the count to 1; followed by unlocking that list... then sure, yeah that will work.

Q6.
Whatever floats your boat. If you want to write a function that locks/unlocks a particular list at index i, instead of just locking/unlocking it then and there, sure.

In the end, the way I implemented the list_lock version was by uniting all the atomic code into a lookup_and_insert_if_absent(Keytype key) call to the hash class. Inside there, all the thread safety (locking) operations happen. It is important to note that the setup and cleanup functions were changed as well, since we added to the actual data structure by adding an array of mutexes.

For the element version, I used the pthread_rwlock_t mutex api because a: it's also in the pthread.h, and b: noone said I can't. This way I avoided any headaches associated with the special case of the element with that key not existing. Normal operation only asks for a reader lock, whereas if a new element has to be inserted, you give up your reader lock and ask for a writer lock. Once you have it, double check the element is still missing, then add, initialize and leave. I had to modify the element class, in this case: the sample class to include a normal mutex lock, which is initialized in the constructor. A destructor had to be added, so that the mutex is destroyed properly during cleanup.

Q7.
Refer to Q2.

Q8
Pros: Don't have to worry about thread synchronization or any race conditions. Cons: Need to allocate more memory foor each induvidual thread to use, instead of the single struture.


